<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BattleLM Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1e1e1e;
        }

        #terminal {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="terminal"></div>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script>
        // 初始化终端
        const term = new Terminal({
            scrollback: 10000,
            fontSize: 12,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            theme: {
                background: '#1e1e1e',
                foreground: '#d4d4d4',
                cursor: '#aeafad',
                cursorAccent: '#000000',
                selectionBackground: '#264f78'
            },
            allowProposedApi: true
        });
        
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal'));
        const terminalEl = document.getElementById('terminal');

        let lastDims = null;
        let resizeTimer = null;
        let readySent = false;

        function postDims(handlerName, dims) {
            try {
                window.webkit?.messageHandlers?.[handlerName]?.postMessage(JSON.stringify(dims));
            } catch (_) { }
        }

        function fitAndNotify() {
            try { fitAddon.fit(); } catch (_) { }

            const dims = { cols: term.cols, rows: term.rows };
            if (!dims.cols || !dims.rows) return;

            if (!readySent) {
                readySent = true;
                postDims('terminalReady', dims);
            }

            if (!lastDims || lastDims.cols !== dims.cols || lastDims.rows !== dims.rows) {
                lastDims = dims;
                postDims('terminalResize', dims);
            }
        }

        function scheduleFit() {
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                resizeTimer = null;
                fitAndNotify();
            }, 50);
        }

        // 避免 WKWebView/xterm 初始化时抢占整个窗口焦点：
        // 让聊天输入框在新建实例/切换视图后仍可立即点击输入。
        try {
            if (document.activeElement) document.activeElement.blur();
            if (term.textarea) term.textarea.blur();
        } catch (_) { }

        // 用户点击终端时才聚焦，避免影响其他输入控件
        document.getElementById('terminal').addEventListener('mousedown', () => {
            try { term.focus(); } catch (_) { }
        });
        
        // 窗口大小变化时重新适配
        window.addEventListener('resize', () => {
            scheduleFit();
        });

        // SwiftUI 分栏/视图切换时，容器尺寸变化不一定触发 window.resize；
        // 使用 ResizeObserver 监控 #terminal 自身尺寸变化，确保 cols/rows 始终准确。
        try {
            const ro = new ResizeObserver(() => scheduleFit());
            ro.observe(terminalEl);
        } catch (_) { }

        // 初次布局完成后再 fit，避免在 0x0 或未完成布局时得到错误的 cols/rows
        requestAnimationFrame(() => scheduleFit());
        
        // 用户输入 → 发送到 Swift
        term.onData(data => {
            window.webkit?.messageHandlers?.terminalInput?.postMessage(data);
        });
        
        // 供 Swift 调用：写入终端数据
        window.writeToTerminal = function(data) {
            term.write(data);
        };
        
        // 供 Swift 调用：写入 base64 编码的数据
        window.writeBase64 = function(base64Data) {
            const bytes = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));
            const text = new TextDecoder().decode(bytes);
            term.write(text);
        };
        
        // 供 Swift 调用：清屏
        window.clearTerminal = function() {
            term.clear();
        };
        
        // 供 Swift 调用：获取终端尺寸
        window.getTerminalSize = function() {
            return JSON.stringify({ cols: term.cols, rows: term.rows });
        };
        
        // 供 Swift 调用：设置主题颜色
        window.setTheme = function(themeJson) {
            try {
                const theme = JSON.parse(themeJson);
                const nextTheme = {
                    background: theme.background || '#1e1e1e',
                    foreground: theme.foreground || '#d4d4d4',
                    cursor: theme.cursor || '#aeafad',
                    cursorAccent: theme.cursorAccent || '#000000',
                    selectionBackground: theme.selection || '#264f78'
                };

                // 兼容不同 xterm 版本：有的版本存在 setOption，有的只支持直接写 term.options。
                try { term.options.theme = nextTheme; } catch (_) { }
                if (typeof term.setOption === 'function') {
                    try { term.setOption('theme', nextTheme); } catch (_) { }
                }

                // 让 HTML/CSS 背景也跟随（xterm 之外的空白区域、以及透明 WebView 下的承接区域）
                try {
                    document.documentElement.style.background = nextTheme.background || '#1e1e1e';
                    document.body.style.background = nextTheme.background || '#1e1e1e';
                    const terminalEl = document.getElementById('terminal');
                    if (terminalEl) terminalEl.style.background = nextTheme.background || '#1e1e1e';
                    const viewports = document.getElementsByClassName('xterm-viewport');
                    for (let i = 0; i < viewports.length; i++) {
                        viewports[i].style.backgroundColor = nextTheme.background || '#1e1e1e';
                    }
                } catch (_) { }

                // 强制刷新可视区域，确保切换主题后立即重绘
                try { term.refresh(0, term.rows - 1); } catch (_) { }
            } catch (e) {
                console.error('Failed to set theme:', e);
            }
        };

        // 兜底：极端情况下（ResizeObserver 不可用等）仍保证会发送 ready
        setTimeout(() => {
            if (!readySent) fitAndNotify();
        }, 300);
    </script>
</body>

</html>
